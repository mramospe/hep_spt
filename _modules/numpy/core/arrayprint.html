
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>numpy.core.arrayprint &#8212; hep_spt 0.0.0.dev4 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for numpy.core.arrayprint</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Array printing function</span>

<span class="sd">$Id: arrayprint.py,v 1.9 2005/09/13 13:58:44 teoliphant Exp $</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;array2string&quot;</span><span class="p">,</span> <span class="s2">&quot;array_str&quot;</span><span class="p">,</span> <span class="s2">&quot;array_repr&quot;</span><span class="p">,</span> <span class="s2">&quot;set_string_function&quot;</span><span class="p">,</span>
           <span class="s2">&quot;set_printoptions&quot;</span><span class="p">,</span> <span class="s2">&quot;get_printoptions&quot;</span><span class="p">,</span> <span class="s2">&quot;printoptions&quot;</span><span class="p">,</span>
           <span class="s2">&quot;format_float_positional&quot;</span><span class="p">,</span> <span class="s2">&quot;format_float_scientific&quot;</span><span class="p">]</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s1">&#39;restructuredtext&#39;</span>

<span class="c1">#</span>
<span class="c1"># Written by Konrad Hinsen &lt;hinsenk@ere.umontreal.ca&gt;</span>
<span class="c1"># last revision: 1996-3-13</span>
<span class="c1"># modified by Jim Hugunin 1997-3-3 for repr&#39;s and str&#39;s (and other details)</span>
<span class="c1"># and by Perry Greenfield 2000-4-1 for numarray</span>
<span class="c1"># and by Travis Oliphant  2005-8-22 for numpy</span>


<span class="c1"># Note: Both scalartypes.c.src and arrayprint.py implement strs for numpy</span>
<span class="c1"># scalars but for different purposes. scalartypes.c.src has str/reprs for when</span>
<span class="c1"># the scalar is printed on its own, while arrayprint.py has strs for when</span>
<span class="c1"># scalars are printed inside an ndarray. Only the latter strs are currently</span>
<span class="c1"># user-customizable.</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_thread</span> <span class="k">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">_dummy_thread</span> <span class="k">import</span> <span class="n">get_ident</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">thread</span> <span class="k">import</span> <span class="n">get_ident</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">dummy_thread</span> <span class="k">import</span> <span class="n">get_ident</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">numerictypes</span> <span class="k">as</span> <span class="n">_nt</span>
<span class="kn">from</span> <span class="nn">.umath</span> <span class="k">import</span> <span class="n">absolute</span><span class="p">,</span> <span class="n">not_equal</span><span class="p">,</span> <span class="n">isnan</span><span class="p">,</span> <span class="n">isinf</span><span class="p">,</span> <span class="n">isfinite</span><span class="p">,</span> <span class="n">isnat</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">multiarray</span>
<span class="kn">from</span> <span class="nn">.multiarray</span> <span class="k">import</span> <span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dragon4_positional</span><span class="p">,</span> <span class="n">dragon4_scientific</span><span class="p">,</span>
                         <span class="n">datetime_as_string</span><span class="p">,</span> <span class="n">datetime_data</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">set_legacy_print_mode</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.fromnumeric</span> <span class="k">import</span> <span class="n">ravel</span><span class="p">,</span> <span class="nb">any</span>
<span class="kn">from</span> <span class="nn">.numeric</span> <span class="k">import</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">errstate</span>
<span class="kn">from</span> <span class="nn">.numerictypes</span> <span class="k">import</span> <span class="p">(</span><span class="n">longlong</span><span class="p">,</span> <span class="n">intc</span><span class="p">,</span> <span class="n">int_</span><span class="p">,</span> <span class="n">float_</span><span class="p">,</span> <span class="n">complex_</span><span class="p">,</span> <span class="n">bool_</span><span class="p">,</span>
                           <span class="n">flexible</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.overrides</span> <span class="k">import</span> <span class="n">array_function_dispatch</span><span class="p">,</span> <span class="n">set_module</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">contextlib</span>

<span class="n">_format_options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;edgeitems&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># repr N leading and trailing items of each dimension</span>
    <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>  <span class="c1"># total items &gt; triggers array summarization</span>
    <span class="s1">&#39;floatmode&#39;</span><span class="p">:</span> <span class="s1">&#39;maxprec&#39;</span><span class="p">,</span>
    <span class="s1">&#39;precision&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>  <span class="c1"># precision of floating point representations</span>
    <span class="s1">&#39;suppress&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># suppress printing small floating values in exp format</span>
    <span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="mi">75</span><span class="p">,</span>
    <span class="s1">&#39;nanstr&#39;</span><span class="p">:</span> <span class="s1">&#39;nan&#39;</span><span class="p">,</span>
    <span class="s1">&#39;infstr&#39;</span><span class="p">:</span> <span class="s1">&#39;inf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sign&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>
    <span class="s1">&#39;formatter&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s1">&#39;legacy&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_make_options_dict</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgeitems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nanstr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">infstr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; make a dictionary out of the non-None arguments, plus sanity checks &quot;&quot;&quot;</span>

    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">suppress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;suppress&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">suppress</span><span class="p">)</span>

    <span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;unique&#39;</span><span class="p">,</span> <span class="s1">&#39;maxprec&#39;</span><span class="p">,</span> <span class="s1">&#39;maxprec_equal&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">floatmode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modes</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;floatmode option must be one of &quot;</span> <span class="o">+</span>
                         <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sign option must be one of &#39; &#39;, &#39;+&#39;, or &#39;-&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">legacy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;1.13&#39;</span><span class="p">]:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;legacy printing option can currently only be &#39;1.13&#39; or &quot;</span>
                      <span class="s2">&quot;`False`&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># forbid the bad threshold arg suggested by stack overflow, gh-12351</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;threshold must be numeric and non-NAN, try &quot;</span>
                             <span class="s2">&quot;sys.maxsize for untruncated representation&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">options</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgeitems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">linewidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nanstr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">infstr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set printing options.</span>

<span class="sd">    These options determine the way floating point numbers, arrays and</span>
<span class="sd">    other NumPy objects are displayed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    precision : int or None, optional</span>
<span class="sd">        Number of digits of precision for floating point output (default 8).</span>
<span class="sd">        May be `None` if `floatmode` is not `fixed`, to print as many digits as</span>
<span class="sd">        necessary to uniquely specify the value.</span>
<span class="sd">    threshold : int, optional</span>
<span class="sd">        Total number of array elements which trigger summarization</span>
<span class="sd">        rather than full repr (default 1000).</span>
<span class="sd">    edgeitems : int, optional</span>
<span class="sd">        Number of array items in summary at beginning and end of</span>
<span class="sd">        each dimension (default 3).</span>
<span class="sd">    linewidth : int, optional</span>
<span class="sd">        The number of characters per line for the purpose of inserting</span>
<span class="sd">        line breaks (default 75).</span>
<span class="sd">    suppress : bool, optional</span>
<span class="sd">        If True, always print floating point numbers using fixed point</span>
<span class="sd">        notation, in which case numbers equal to zero in the current precision</span>
<span class="sd">        will print as zero.  If False, then scientific notation is used when</span>
<span class="sd">        absolute value of the smallest number is &lt; 1e-4 or the ratio of the</span>
<span class="sd">        maximum absolute value to the minimum is &gt; 1e3. The default is False.</span>
<span class="sd">    nanstr : str, optional</span>
<span class="sd">        String representation of floating point not-a-number (default nan).</span>
<span class="sd">    infstr : str, optional</span>
<span class="sd">        String representation of floating point infinity (default inf).</span>
<span class="sd">    sign : string, either &#39;-&#39;, &#39;+&#39;, or &#39; &#39;, optional</span>
<span class="sd">        Controls printing of the sign of floating-point types. If &#39;+&#39;, always</span>
<span class="sd">        print the sign of positive values. If &#39; &#39;, always prints a space</span>
<span class="sd">        (whitespace character) in the sign position of positive values.  If</span>
<span class="sd">        &#39;-&#39;, omit the sign character of positive values. (default &#39;-&#39;)</span>
<span class="sd">    formatter : dict of callables, optional</span>
<span class="sd">        If not None, the keys should indicate the type(s) that the respective</span>
<span class="sd">        formatting function applies to.  Callables should return a string.</span>
<span class="sd">        Types that are not specified (by their corresponding keys) are handled</span>
<span class="sd">        by the default formatters.  Individual types for which a formatter</span>
<span class="sd">        can be set are:</span>

<span class="sd">        - &#39;bool&#39;</span>
<span class="sd">        - &#39;int&#39;</span>
<span class="sd">        - &#39;timedelta&#39; : a `numpy.timedelta64`</span>
<span class="sd">        - &#39;datetime&#39; : a `numpy.datetime64`</span>
<span class="sd">        - &#39;float&#39;</span>
<span class="sd">        - &#39;longfloat&#39; : 128-bit floats</span>
<span class="sd">        - &#39;complexfloat&#39;</span>
<span class="sd">        - &#39;longcomplexfloat&#39; : composed of two 128-bit floats</span>
<span class="sd">        - &#39;numpystr&#39; : types `numpy.string_` and `numpy.unicode_`</span>
<span class="sd">        - &#39;object&#39; : `np.object_` arrays</span>
<span class="sd">        - &#39;str&#39; : all other strings</span>

<span class="sd">        Other keys that can be used to set a group of types at once are:</span>

<span class="sd">        - &#39;all&#39; : sets all types</span>
<span class="sd">        - &#39;int_kind&#39; : sets &#39;int&#39;</span>
<span class="sd">        - &#39;float_kind&#39; : sets &#39;float&#39; and &#39;longfloat&#39;</span>
<span class="sd">        - &#39;complex_kind&#39; : sets &#39;complexfloat&#39; and &#39;longcomplexfloat&#39;</span>
<span class="sd">        - &#39;str_kind&#39; : sets &#39;str&#39; and &#39;numpystr&#39;</span>
<span class="sd">    floatmode : str, optional</span>
<span class="sd">        Controls the interpretation of the `precision` option for</span>
<span class="sd">        floating-point types. Can take the following values</span>
<span class="sd">        (default maxprec_equal):</span>

<span class="sd">        * &#39;fixed&#39;: Always print exactly `precision` fractional digits,</span>
<span class="sd">                even if this would print more or fewer digits than</span>
<span class="sd">                necessary to specify the value uniquely.</span>
<span class="sd">        * &#39;unique&#39;: Print the minimum number of fractional digits necessary</span>
<span class="sd">                to represent each value uniquely. Different elements may</span>
<span class="sd">                have a different number of digits. The value of the</span>
<span class="sd">                `precision` option is ignored.</span>
<span class="sd">        * &#39;maxprec&#39;: Print at most `precision` fractional digits, but if</span>
<span class="sd">                an element can be uniquely represented with fewer digits</span>
<span class="sd">                only print it with that many.</span>
<span class="sd">        * &#39;maxprec_equal&#39;: Print at most `precision` fractional digits,</span>
<span class="sd">                but if every element in the array can be uniquely</span>
<span class="sd">                represented with an equal number of fewer digits, use that</span>
<span class="sd">                many digits for all elements.</span>
<span class="sd">    legacy : string or `False`, optional</span>
<span class="sd">        If set to the string `&#39;1.13&#39;` enables 1.13 legacy printing mode. This</span>
<span class="sd">        approximates numpy 1.13 print output by including a space in the sign</span>
<span class="sd">        position of floats and different behavior for 0d arrays. If set to</span>
<span class="sd">        `False`, disables legacy mode. Unrecognized strings will be ignored</span>
<span class="sd">        with a warning for forward compatibility.</span>

<span class="sd">        .. versionadded:: 1.14.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    get_printoptions, set_string_function, array2string</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `formatter` is always reset with a call to `set_printoptions`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Floating point precision can be set:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(precision=4)</span>
<span class="sd">    &gt;&gt;&gt; np.array([1.123456789])</span>
<span class="sd">    [1.1235]</span>

<span class="sd">    Long arrays can be summarised:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(threshold=5)</span>
<span class="sd">    &gt;&gt;&gt; np.arange(10)</span>
<span class="sd">    array([0, 1, 2, ..., 7, 8, 9])</span>

<span class="sd">    Small results can be suppressed:</span>

<span class="sd">    &gt;&gt;&gt; eps = np.finfo(float).eps</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(4.)</span>
<span class="sd">    &gt;&gt;&gt; x**2 - (x + eps)**2</span>
<span class="sd">    array([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])</span>
<span class="sd">    &gt;&gt;&gt; np.set_printoptions(suppress=True)</span>
<span class="sd">    &gt;&gt;&gt; x**2 - (x + eps)**2</span>
<span class="sd">    array([-0., -0.,  0.,  0.])</span>

<span class="sd">    A custom formatter can be used to display array elements as desired:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(formatter={&#39;all&#39;:lambda x: &#39;int: &#39;+str(-x)})</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([int: 0, int: -1, int: -2])</span>
<span class="sd">    &gt;&gt;&gt; np.set_printoptions()  # formatter gets reset</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([0, 1, 2])</span>

<span class="sd">    To put back the default options, you can use:</span>

<span class="sd">    &gt;&gt;&gt; np.set_printoptions(edgeitems=3,infstr=&#39;inf&#39;,</span>
<span class="sd">    ... linewidth=75, nanstr=&#39;nan&#39;, precision=8,</span>
<span class="sd">    ... suppress=False, threshold=1000, formatter=None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">legacy</span> <span class="o">=</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;legacy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwarg</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;set_printoptions() got unexpected keyword argument &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwarg</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">opt</span> <span class="o">=</span> <span class="n">_make_options_dict</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span>
                             <span class="n">suppress</span><span class="p">,</span> <span class="n">nanstr</span><span class="p">,</span> <span class="n">infstr</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">formatter</span><span class="p">,</span>
                             <span class="n">floatmode</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>
    <span class="c1"># formatter is always reset</span>
    <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;formatter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">formatter</span>
    <span class="n">_format_options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>

    <span class="c1"># set the C variable for legacy mode</span>
    <span class="k">if</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
        <span class="n">set_legacy_print_mode</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
        <span class="c1"># reset the sign option in legacy mode to avoid confusion</span>
        <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;sign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
    <span class="k">elif</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">set_legacy_print_mode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_printoptions</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the current print options.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    print_opts : dict</span>
<span class="sd">        Dictionary of current print options with keys</span>

<span class="sd">          - precision : int</span>
<span class="sd">          - threshold : int</span>
<span class="sd">          - edgeitems : int</span>
<span class="sd">          - linewidth : int</span>
<span class="sd">          - suppress : bool</span>
<span class="sd">          - nanstr : str</span>
<span class="sd">          - infstr : str</span>
<span class="sd">          - formatter : dict of callables</span>
<span class="sd">          - sign : str</span>

<span class="sd">        For a full description of these options, see `set_printoptions`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    set_printoptions, set_string_function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_format_options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Context manager for setting print options.</span>

<span class="sd">    Set print options for the scope of the `with` block, and restore the old</span>
<span class="sd">    options at the end. See `set_printoptions` for the full description of</span>
<span class="sd">    available options.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from numpy.testing import assert_equal</span>
<span class="sd">    &gt;&gt;&gt; with np.printoptions(precision=2):</span>
<span class="sd">    ...     np.array([2.0]) / 3</span>
<span class="sd">    array([0.67])</span>

<span class="sd">    The `as`-clause of the `with`-statement gives the current print options:</span>

<span class="sd">    &gt;&gt;&gt; with np.printoptions(precision=2) as opts:</span>
<span class="sd">    ...      assert_equal(opts, np.get_printoptions())</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    set_printoptions, get_printoptions</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="o">**</span><span class="n">opts</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_leading_trailing</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Keep only the N-D corners (leading and trailing edges) of an array.</span>

<span class="sd">    Should be passed a base-class ndarray, since it makes no guarantees about</span>
<span class="sd">    preserving subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">edgeitems</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concatenate</span><span class="p">((</span>
            <span class="n">_leading_trailing</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span> <span class="p">:</span><span class="n">edgeitems</span><span class="p">]),</span>
            <span class="n">_leading_trailing</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="o">-</span><span class="n">edgeitems</span><span class="p">:])</span>
        <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_leading_trailing</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:])</span>


<span class="k">def</span> <span class="nf">_object_format</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Object arrays containing lists should be printed unambiguously &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;list(</span><span class="si">{!r}</span><span class="s1">)&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">repr_format</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">str_format</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_formatdict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">opt</span><span class="p">):</span>
    <span class="n">prec</span><span class="p">,</span> <span class="n">fmode</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;precision&#39;</span><span class="p">],</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;floatmode&#39;</span><span class="p">]</span>
    <span class="n">supp</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;suppress&#39;</span><span class="p">],</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;sign&#39;</span><span class="p">]</span>
    <span class="n">legacy</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span>

    <span class="c1"># wrapped in lambdas to avoid taking a code path with the wrong type of data</span>
    <span class="n">formatdict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;bool&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">BoolFormat</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">IntegerFormat</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span>
            <span class="n">FloatingFormat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">fmode</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">),</span>
        <span class="s1">&#39;longfloat&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span>
            <span class="n">FloatingFormat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">fmode</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">),</span>
        <span class="s1">&#39;complexfloat&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span>
            <span class="n">ComplexFloatingFormat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">fmode</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">),</span>
        <span class="s1">&#39;longcomplexfloat&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span>
            <span class="n">ComplexFloatingFormat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">fmode</span><span class="p">,</span> <span class="n">supp</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">),</span>
        <span class="s1">&#39;datetime&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">DatetimeFormat</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="n">legacy</span><span class="p">),</span>
        <span class="s1">&#39;timedelta&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">TimedeltaFormat</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;object&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">_object_format</span><span class="p">,</span>
        <span class="s1">&#39;void&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">str_format</span><span class="p">,</span>
        <span class="s1">&#39;numpystr&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">repr_format</span><span class="p">,</span>
        <span class="s1">&#39;str&#39;</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>

    <span class="c1"># we need to wrap values in `formatter` in a lambda, so that the interface</span>
    <span class="c1"># is the same as the above values.</span>
    <span class="k">def</span> <span class="nf">indirect</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">x</span>

    <span class="n">formatter</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;formatter&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">formatter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fkeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">formatter</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">formatter</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;all&#39;</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">formatdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;int_kind&#39;</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">]:</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="s1">&#39;int_kind&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;float_kind&#39;</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;longfloat&#39;</span><span class="p">]:</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="s1">&#39;float_kind&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;complex_kind&#39;</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;complexfloat&#39;</span><span class="p">,</span> <span class="s1">&#39;longcomplexfloat&#39;</span><span class="p">]:</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="s1">&#39;complex_kind&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;str_kind&#39;</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;numpystr&#39;</span><span class="p">,</span> <span class="s1">&#39;str&#39;</span><span class="p">]:</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="s1">&#39;str_kind&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">formatdict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fkeys</span><span class="p">:</span>
                <span class="n">formatdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">indirect</span><span class="p">(</span><span class="n">formatter</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">formatdict</span>

<span class="k">def</span> <span class="nf">_get_format_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    find the right formatting function for the dtype_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">dtypeobj</span> <span class="o">=</span> <span class="n">dtype_</span><span class="o">.</span><span class="n">type</span>
    <span class="n">formatdict</span> <span class="o">=</span> <span class="n">_get_formatdict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;timedelta&#39;</span><span class="p">]()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">longfloat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;longfloat&#39;</span><span class="p">]()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;float&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">clongfloat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;longcomplexfloat&#39;</span><span class="p">]()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;complexfloat&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="p">(</span><span class="n">_nt</span><span class="o">.</span><span class="n">unicode_</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">string_</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;numpystr&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">object_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;object&#39;</span><span class="p">]()</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtypeobj</span><span class="p">,</span> <span class="n">_nt</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype_</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">StructuredVoidFormat</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;void&#39;</span><span class="p">]()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">formatdict</span><span class="p">[</span><span class="s1">&#39;numpystr&#39;</span><span class="p">]()</span>


<span class="k">def</span> <span class="nf">_recursive_guard</span><span class="p">(</span><span class="n">fillvalue</span><span class="o">=</span><span class="s1">&#39;...&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like the python 3.2 reprlib.recursive_repr, but forwards *args and **kwargs</span>

<span class="sd">    Decorates a function such that if it calls itself with the same first</span>
<span class="sd">    argument, it returns `fillvalue` instead of recursing.</span>

<span class="sd">    Largely copied from reprlib.recursive_repr</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorating_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">repr_running</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">get_ident</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">repr_running</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fillvalue</span>
            <span class="n">repr_running</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">repr_running</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="k">return</span> <span class="n">decorating_function</span>


<span class="c1"># gracefully handle recursive calls, when object arrays contain themselves</span>
<span class="nd">@_recursive_guard</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">_array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="c1"># The formatter __init__s in _get_format_function cannot deal with</span>
    <span class="c1"># subclasses yet, and we also need to avoid recursion issues in</span>
    <span class="c1"># _formatArray with subclasses which return 0d arrays in place of scalars</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;threshold&#39;</span><span class="p">]:</span>
        <span class="n">summary_insert</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_leading_trailing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;edgeitems&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">summary_insert</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># find the right formatting function for the array</span>
    <span class="n">format_function</span> <span class="o">=</span> <span class="n">_get_format_function</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="c1"># skip over &quot;[&quot;</span>
    <span class="n">next_line_prefix</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="c1"># skip over array(</span>
    <span class="n">next_line_prefix</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

    <span class="n">lst</span> <span class="o">=</span> <span class="n">_formatArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">format_function</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">],</span>
                       <span class="n">next_line_prefix</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;edgeitems&#39;</span><span class="p">],</span>
                       <span class="n">summary_insert</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">lst</span>


<span class="k">def</span> <span class="nf">_array2string_dispatcher</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edgeitems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_array2string_dispatcher</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="n">style</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">edgeitems</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floatmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representation of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    max_line_width : int, optional</span>
<span class="sd">        Inserts newlines if text is longer than `max_line_width`.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;linewidth&#39;]``.</span>
<span class="sd">    precision : int or None, optional</span>
<span class="sd">        Floating point precision.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;precision&#39;]``.</span>
<span class="sd">    suppress_small : bool, optional</span>
<span class="sd">        Represent numbers &quot;very close&quot; to zero as zero; default is False.</span>
<span class="sd">        Very close is defined by precision: if the precision is 8, e.g.,</span>
<span class="sd">        numbers smaller (in absolute value) than 5e-9 are represented as</span>
<span class="sd">        zero.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;suppress&#39;]``.</span>
<span class="sd">    separator : str, optional</span>
<span class="sd">        Inserted between elements.</span>
<span class="sd">    prefix : str, optional</span>
<span class="sd">    suffix: str, optional</span>
<span class="sd">        The length of the prefix and suffix strings are used to respectively</span>
<span class="sd">        align and wrap the output. An array is typically printed as::</span>

<span class="sd">          prefix + array2string(a) + suffix</span>

<span class="sd">        The output is left-padded by the length of the prefix string, and</span>
<span class="sd">        wrapping is forced at the column ``max_line_width - len(suffix)``.</span>
<span class="sd">        It should be noted that the content of prefix and suffix strings are</span>
<span class="sd">        not included in the output.</span>
<span class="sd">    style : _NoValue, optional</span>
<span class="sd">        Has no effect, do not use.</span>

<span class="sd">        .. deprecated:: 1.14.0</span>
<span class="sd">    formatter : dict of callables, optional</span>
<span class="sd">        If not None, the keys should indicate the type(s) that the respective</span>
<span class="sd">        formatting function applies to.  Callables should return a string.</span>
<span class="sd">        Types that are not specified (by their corresponding keys) are handled</span>
<span class="sd">        by the default formatters.  Individual types for which a formatter</span>
<span class="sd">        can be set are:</span>

<span class="sd">        - &#39;bool&#39;</span>
<span class="sd">        - &#39;int&#39;</span>
<span class="sd">        - &#39;timedelta&#39; : a `numpy.timedelta64`</span>
<span class="sd">        - &#39;datetime&#39; : a `numpy.datetime64`</span>
<span class="sd">        - &#39;float&#39;</span>
<span class="sd">        - &#39;longfloat&#39; : 128-bit floats</span>
<span class="sd">        - &#39;complexfloat&#39;</span>
<span class="sd">        - &#39;longcomplexfloat&#39; : composed of two 128-bit floats</span>
<span class="sd">        - &#39;void&#39; : type `numpy.void`</span>
<span class="sd">        - &#39;numpystr&#39; : types `numpy.string_` and `numpy.unicode_`</span>
<span class="sd">        - &#39;str&#39; : all other strings</span>

<span class="sd">        Other keys that can be used to set a group of types at once are:</span>

<span class="sd">        - &#39;all&#39; : sets all types</span>
<span class="sd">        - &#39;int_kind&#39; : sets &#39;int&#39;</span>
<span class="sd">        - &#39;float_kind&#39; : sets &#39;float&#39; and &#39;longfloat&#39;</span>
<span class="sd">        - &#39;complex_kind&#39; : sets &#39;complexfloat&#39; and &#39;longcomplexfloat&#39;</span>
<span class="sd">        - &#39;str_kind&#39; : sets &#39;str&#39; and &#39;numpystr&#39;</span>
<span class="sd">    threshold : int, optional</span>
<span class="sd">        Total number of array elements which trigger summarization</span>
<span class="sd">        rather than full repr.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;threshold&#39;]``.</span>
<span class="sd">    edgeitems : int, optional</span>
<span class="sd">        Number of array items in summary at beginning and end of</span>
<span class="sd">        each dimension.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;edgeitems&#39;]``.</span>
<span class="sd">    sign : string, either &#39;-&#39;, &#39;+&#39;, or &#39; &#39;, optional</span>
<span class="sd">        Controls printing of the sign of floating-point types. If &#39;+&#39;, always</span>
<span class="sd">        print the sign of positive values. If &#39; &#39;, always prints a space</span>
<span class="sd">        (whitespace character) in the sign position of positive values.  If</span>
<span class="sd">        &#39;-&#39;, omit the sign character of positive values.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;sign&#39;]``.</span>
<span class="sd">    floatmode : str, optional</span>
<span class="sd">        Controls the interpretation of the `precision` option for</span>
<span class="sd">        floating-point types.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;floatmode&#39;]``.</span>
<span class="sd">        Can take the following values:</span>

<span class="sd">        - &#39;fixed&#39;: Always print exactly `precision` fractional digits,</span>
<span class="sd">          even if this would print more or fewer digits than</span>
<span class="sd">          necessary to specify the value uniquely.</span>
<span class="sd">        - &#39;unique&#39;: Print the minimum number of fractional digits necessary</span>
<span class="sd">          to represent each value uniquely. Different elements may</span>
<span class="sd">          have a different number of digits.  The value of the</span>
<span class="sd">          `precision` option is ignored.</span>
<span class="sd">        - &#39;maxprec&#39;: Print at most `precision` fractional digits, but if</span>
<span class="sd">          an element can be uniquely represented with fewer digits</span>
<span class="sd">          only print it with that many.</span>
<span class="sd">        - &#39;maxprec_equal&#39;: Print at most `precision` fractional digits,</span>
<span class="sd">          but if every element in the array can be uniquely</span>
<span class="sd">          represented with an equal number of fewer digits, use that</span>
<span class="sd">          many digits for all elements.</span>
<span class="sd">    legacy : string or `False`, optional</span>
<span class="sd">        If set to the string `&#39;1.13&#39;` enables 1.13 legacy printing mode. This</span>
<span class="sd">        approximates numpy 1.13 print output by including a space in the sign</span>
<span class="sd">        position of floats and different behavior for 0d arrays. If set to</span>
<span class="sd">        `False`, disables legacy mode. Unrecognized strings will be ignored</span>
<span class="sd">        with a warning for forward compatibility.</span>

<span class="sd">        .. versionadded:: 1.14.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_str : str</span>
<span class="sd">        String representation of the array.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        if a callable in `formatter` does not return a string.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    array_str, array_repr, set_printoptions, get_printoptions</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If a formatter is specified for a certain type, the `precision` keyword is</span>
<span class="sd">    ignored for that type.</span>

<span class="sd">    This is a very flexible function; `array_repr` and `array_str` are using</span>
<span class="sd">    `array2string` internally so keywords with the same name should work</span>
<span class="sd">    identically in all three functions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1e-16,1,2,3])</span>
<span class="sd">    &gt;&gt;&gt; np.array2string(x, precision=2, separator=&#39;,&#39;,</span>
<span class="sd">    ...                       suppress_small=True)</span>
<span class="sd">    &#39;[0.,1.,2.,3.]&#39;</span>

<span class="sd">    &gt;&gt;&gt; x  = np.arange(3.)</span>
<span class="sd">    &gt;&gt;&gt; np.array2string(x, formatter={&#39;float_kind&#39;:lambda x: &quot;%.2f&quot; % x})</span>
<span class="sd">    &#39;[0.00 1.00 2.00]&#39;</span>

<span class="sd">    &gt;&gt;&gt; x  = np.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; np.array2string(x, formatter={&#39;int&#39;:lambda x: hex(x)})</span>
<span class="sd">    &#39;[0x0 0x1 0x2]&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">legacy</span> <span class="o">=</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;legacy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwarg</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;array2string() got unexpected keyword argument &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwarg</span><span class="o">.</span><span class="n">popitem</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">overrides</span> <span class="o">=</span> <span class="n">_make_options_dict</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">edgeitems</span><span class="p">,</span>
                                   <span class="n">max_line_width</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                   <span class="n">sign</span><span class="p">,</span> <span class="n">formatter</span><span class="p">,</span> <span class="n">floatmode</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">_format_options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">overrides</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">style</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="nb">repr</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">style</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">style</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># Deprecation 11-9-2017  v1.14</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;style&#39; argument is deprecated and no longer functional&quot;</span>
                      <span class="s2">&quot; except in 1.13 &#39;legacy&#39; mode&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
        <span class="n">options</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>

    <span class="c1"># treat as a null array if any of shape elements == 0</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;[]&quot;</span>

    <span class="k">return</span> <span class="n">_array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_extendLine</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">line_width</span><span class="p">,</span> <span class="n">next_line_prefix</span><span class="p">,</span> <span class="n">legacy</span><span class="p">):</span>
    <span class="n">needs_wrap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">line_width</span>
    <span class="k">if</span> <span class="n">legacy</span> <span class="o">!=</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
        <span class="n">s</span><span class="c1"># don&#39;t wrap lines if it won&#39;t help</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_line_prefix</span><span class="p">):</span>
            <span class="n">needs_wrap</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">needs_wrap</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">next_line_prefix</span>
    <span class="n">line</span> <span class="o">+=</span> <span class="n">word</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">line</span>


<span class="k">def</span> <span class="nf">_formatArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">format_function</span><span class="p">,</span> <span class="n">line_width</span><span class="p">,</span> <span class="n">next_line_prefix</span><span class="p">,</span>
                 <span class="n">separator</span><span class="p">,</span> <span class="n">edge_items</span><span class="p">,</span> <span class="n">summary_insert</span><span class="p">,</span> <span class="n">legacy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;formatArray is designed for two modes of operation:</span>

<span class="sd">    1. Full output</span>

<span class="sd">    2. Summarized output</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">recurser</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">hanging_indent</span><span class="p">,</span> <span class="n">curr_width</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        By using this local function, we don&#39;t need to recurse with all the</span>
<span class="sd">        arguments. Since this function is not created recursively, the cost is</span>
<span class="sd">        not significant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">axes_left</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="n">axes_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">format_function</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># when recursing, add a space to align with the [ added, and reduce the</span>
        <span class="c1"># length of the line by 1</span>
        <span class="n">next_hanging_indent</span> <span class="o">=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span>
        <span class="k">if</span> <span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="n">next_width</span> <span class="o">=</span> <span class="n">curr_width</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">next_width</span> <span class="o">=</span> <span class="n">curr_width</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)</span>

        <span class="n">a_len</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">show_summary</span> <span class="o">=</span> <span class="n">summary_insert</span> <span class="ow">and</span> <span class="mi">2</span><span class="o">*</span><span class="n">edge_items</span> <span class="o">&lt;</span> <span class="n">a_len</span>
        <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
            <span class="n">leading_items</span> <span class="o">=</span> <span class="n">edge_items</span>
            <span class="n">trailing_items</span> <span class="o">=</span> <span class="n">edge_items</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leading_items</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">trailing_items</span> <span class="o">=</span> <span class="n">a_len</span>

        <span class="c1"># stringify the array with the hanging indent on the first line too</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># last axis (rows) - wrap elements if they would not fit on one line</span>
        <span class="k">if</span> <span class="n">axes_left</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># the length up until the beginning of the separator / bracket</span>
            <span class="k">if</span> <span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                <span class="n">elem_width</span> <span class="o">=</span> <span class="n">curr_width</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">separator</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elem_width</span> <span class="o">=</span> <span class="n">curr_width</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">separator</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">))</span>

            <span class="n">line</span> <span class="o">=</span> <span class="n">hanging_indent</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leading_items</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span> <span class="n">next_width</span><span class="p">)</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extendLine</span><span class="p">(</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">elem_width</span><span class="p">,</span> <span class="n">hanging_indent</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="n">separator</span>

            <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extendLine</span><span class="p">(</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">summary_insert</span><span class="p">,</span> <span class="n">elem_width</span><span class="p">,</span> <span class="n">hanging_indent</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="n">separator</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trailing_items</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span> <span class="n">next_width</span><span class="p">)</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extendLine</span><span class="p">(</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">elem_width</span><span class="p">,</span> <span class="n">hanging_indent</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="n">separator</span>

            <span class="k">if</span> <span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                <span class="c1"># width of the separator is not considered on 1.13</span>
                <span class="n">elem_width</span> <span class="o">=</span> <span class="n">curr_width</span>
            <span class="n">word</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span> <span class="n">next_width</span><span class="p">)</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">_extendLine</span><span class="p">(</span>
                <span class="n">s</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">elem_width</span><span class="p">,</span> <span class="n">hanging_indent</span><span class="p">,</span> <span class="n">legacy</span><span class="p">)</span>

            <span class="n">s</span> <span class="o">+=</span> <span class="n">line</span>

        <span class="c1"># other axes - insert newlines between rows</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">line_sep</span> <span class="o">=</span> <span class="n">separator</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">axes_left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">leading_items</span><span class="p">):</span>
                <span class="n">nested</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span> <span class="n">next_width</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="n">nested</span> <span class="o">+</span> <span class="n">line_sep</span>

            <span class="k">if</span> <span class="n">show_summary</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                    <span class="c1"># trailing space, fixed nbr of newlines, and fixed separator</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="n">summary_insert</span> <span class="o">+</span> <span class="s2">&quot;, </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="n">summary_insert</span> <span class="o">+</span> <span class="n">line_sep</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trailing_items</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">nested</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span>
                                  <span class="n">next_width</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="n">nested</span> <span class="o">+</span> <span class="n">line_sep</span>

            <span class="n">nested</span> <span class="o">=</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="n">next_hanging_indent</span><span class="p">,</span> <span class="n">next_width</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">hanging_indent</span> <span class="o">+</span> <span class="n">nested</span>

        <span class="c1"># remove the hanging indent, and wrap in []</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">hanging_indent</span><span class="p">):]</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># invoke the recursive part with an initial index and prefix</span>
        <span class="k">return</span> <span class="n">recurser</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">(),</span>
                        <span class="n">hanging_indent</span><span class="o">=</span><span class="n">next_line_prefix</span><span class="p">,</span>
                        <span class="n">curr_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># recursive closures have a cyclic reference to themselves, which</span>
        <span class="c1"># requires gc to collect (gh-10620). To avoid this problem, for</span>
        <span class="c1"># performance and PyPy friendliness, we break the cycle:</span>
        <span class="n">recurser</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">_none_or_positive_arg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must be &gt;= 0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">FloatingFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Formatter for subtypes of np.floating &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">floatmode</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
        <span class="c1"># for backcompatibility, accept bools</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">=</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;legacy&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="c1"># when not 0d, legacy does not support &#39;-&#39;</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">floatmode</span> <span class="o">=</span> <span class="n">floatmode</span>
        <span class="k">if</span> <span class="n">floatmode</span> <span class="o">==</span> <span class="s1">&#39;unique&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_small</span> <span class="o">=</span> <span class="n">suppress_small</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exp_format</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">large_exponent</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fillFormat</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fillFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># only the finite values are used to compute the number of digits</span>
        <span class="n">finite_vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>

        <span class="c1"># choose exponential mode based on the non-zero finite values:</span>
        <span class="n">abs_non_zero</span> <span class="o">=</span> <span class="n">absolute</span><span class="p">(</span><span class="n">finite_vals</span><span class="p">[</span><span class="n">finite_vals</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abs_non_zero</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">abs_non_zero</span><span class="p">)</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_non_zero</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">errstate</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>  <span class="c1"># division can overflow</span>
                <span class="k">if</span> <span class="n">max_val</span> <span class="o">&gt;=</span> <span class="mf">1.e8</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_small</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">min_val</span> <span class="o">&lt;</span> <span class="mf">0.0001</span> <span class="ow">or</span> <span class="n">max_val</span><span class="o">/</span><span class="n">min_val</span> <span class="o">&gt;</span> <span class="mf">1000.</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exp_format</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># do a first pass of printing all the numbers, to determine sizes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">finite_vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exp_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_format</span><span class="p">:</span>
            <span class="n">trim</span><span class="p">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floatmode</span> <span class="o">==</span> <span class="s1">&#39;fixed&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                <span class="n">trim</span><span class="p">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="kc">False</span>
            <span class="n">strs</span> <span class="o">=</span> <span class="p">(</span><span class="n">dragon4_scientific</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                               <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">finite_vals</span><span class="p">)</span>
            <span class="n">frac_strs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">exp_strs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">))</span>
            <span class="n">int_part</span><span class="p">,</span> <span class="n">frac_part</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">frac_strs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exp_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">exp_strs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">frac_part</span><span class="p">)</span>

            <span class="c1"># for back-compat with np 1.13, use 2 spaces &amp; sign and full prec</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this should be only 1 or 2. Can be calculated from sign.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">int_part</span><span class="p">)</span>
            <span class="c1"># pad_right is only needed for nan length calculation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_size</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># first pass printing to determine sizes</span>
            <span class="n">trim</span><span class="p">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floatmode</span> <span class="o">==</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span>
                <span class="n">trim</span><span class="p">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="kc">False</span>
            <span class="n">strs</span> <span class="o">=</span> <span class="p">(</span><span class="n">dragon4_positional</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                                       <span class="n">fractional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">,</span>
                                       <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">finite_vals</span><span class="p">)</span>
            <span class="n">int_part</span><span class="p">,</span> <span class="n">frac_part</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-+&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">int_part</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">int_part</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">frac_part</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exp_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floatmode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fixed&#39;</span><span class="p">,</span> <span class="s1">&#39;maxprec_equal&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_legacy</span> <span class="o">!=</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="c1"># account for sign = &#39; &#39; by adding one to pad_left</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">finite_vals</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># if there are non-finite values, may need to increase pad_left</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">finite_vals</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">neginf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">isinf</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">nanlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;nanstr&#39;</span><span class="p">])</span>
            <span class="n">inflen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;infstr&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">neginf</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for decimal pt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span> <span class="n">nanlen</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">inflen</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;nanstr&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># isinf</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">+</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;infstr&#39;</span><span class="p">]</span>
                <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span> <span class="o">+</span> <span class="n">ret</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp_format</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dragon4_scientific</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                                      <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                                      <span class="n">unique</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">,</span>
                                      <span class="n">trim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">,</span>
                                      <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
                                      <span class="n">pad_left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span>
                                      <span class="n">exp_digits</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exp_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dragon4_positional</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                                      <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                                      <span class="n">unique</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">,</span>
                                      <span class="n">fractional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="n">trim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">,</span>
                                      <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
                                      <span class="n">pad_left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span>
                                      <span class="n">pad_right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span><span class="p">)</span>

<span class="c1"># for back-compatibility, we keep the classes for each float type too</span>
<span class="k">class</span> <span class="nc">FloatFormat</span><span class="p">(</span><span class="n">FloatingFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;FloatFormat has been replaced by FloatingFormat&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FloatFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LongFloatFormat</span><span class="p">(</span><span class="n">FloatingFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;LongFloatFormat has been replaced by FloatingFormat&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LongFloatFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">format_float_scientific</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                            <span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pad_left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exp_digits</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format a floating-point scalar as a decimal string in scientific notation.</span>

<span class="sd">    Provides control over rounding, trimming and padding. Uses and assumes</span>
<span class="sd">    IEEE unbiased rounding. Uses the &quot;Dragon4&quot; algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : python float or numpy floating scalar</span>
<span class="sd">        Value to format.</span>
<span class="sd">    precision : non-negative integer or None, optional</span>
<span class="sd">        Maximum number of digits to print. May be None if `unique` is</span>
<span class="sd">        `True`, but must be an integer if unique is `False`.</span>
<span class="sd">    unique : boolean, optional</span>
<span class="sd">        If `True`, use a digit-generation strategy which gives the shortest</span>
<span class="sd">        representation which uniquely identifies the floating-point number from</span>
<span class="sd">        other values of the same type, by judicious rounding. If `precision`</span>
<span class="sd">        was omitted, print all necessary digits, otherwise digit generation is</span>
<span class="sd">        cut off after `precision` digits and the remaining value is rounded.</span>
<span class="sd">        If `False`, digits are generated as if printing an infinite-precision</span>
<span class="sd">        value and stopping after `precision` digits, rounding the remaining</span>
<span class="sd">        value.</span>
<span class="sd">    trim : one of &#39;k&#39;, &#39;.&#39;, &#39;0&#39;, &#39;-&#39;, optional</span>
<span class="sd">        Controls post-processing trimming of trailing digits, as follows:</span>

<span class="sd">        * &#39;k&#39; : keep trailing zeros, keep decimal point (no trimming)</span>
<span class="sd">        * &#39;.&#39; : trim all trailing zeros, leave decimal point</span>
<span class="sd">        * &#39;0&#39; : trim all but the zero before the decimal point. Insert the</span>
<span class="sd">          zero if it is missing.</span>
<span class="sd">        * &#39;-&#39; : trim trailing zeros and any trailing decimal point</span>
<span class="sd">    sign : boolean, optional</span>
<span class="sd">        Whether to show the sign for positive values.</span>
<span class="sd">    pad_left : non-negative integer, optional</span>
<span class="sd">        Pad the left side of the string with whitespace until at least that</span>
<span class="sd">        many characters are to the left of the decimal point.</span>
<span class="sd">    exp_digits : non-negative integer, optional</span>
<span class="sd">        Pad the exponent with zeros until it contains at least this many digits.</span>
<span class="sd">        If omitted, the exponent will be at least 2 digits.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rep : string</span>
<span class="sd">        The string representation of the floating point value</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    format_float_positional</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_scientific(np.float32(np.pi))</span>
<span class="sd">    &#39;3.1415927e+00&#39;</span>
<span class="sd">    &gt;&gt;&gt; s = np.float32(1.23e24)</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_scientific(s, unique=False, precision=15)</span>
<span class="sd">    &#39;1.230000071797338e+24&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_scientific(s, exp_digits=4)</span>
<span class="sd">    &#39;1.23e+0024&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">)</span>
    <span class="n">pad_left</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">pad_left</span><span class="p">,</span> <span class="s1">&#39;pad_left&#39;</span><span class="p">)</span>
    <span class="n">exp_digits</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">exp_digits</span><span class="p">,</span> <span class="s1">&#39;exp_digits&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dragon4_scientific</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
                              <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">pad_left</span><span class="o">=</span><span class="n">pad_left</span><span class="p">,</span>
                              <span class="n">exp_digits</span><span class="o">=</span><span class="n">exp_digits</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">format_float_positional</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">fractional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">pad_left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format a floating-point scalar as a decimal string in positional notation.</span>

<span class="sd">    Provides control over rounding, trimming and padding. Uses and assumes</span>
<span class="sd">    IEEE unbiased rounding. Uses the &quot;Dragon4&quot; algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : python float or numpy floating scalar</span>
<span class="sd">        Value to format.</span>
<span class="sd">    precision : non-negative integer or None, optional</span>
<span class="sd">        Maximum number of digits to print. May be None if `unique` is</span>
<span class="sd">        `True`, but must be an integer if unique is `False`.</span>
<span class="sd">    unique : boolean, optional</span>
<span class="sd">        If `True`, use a digit-generation strategy which gives the shortest</span>
<span class="sd">        representation which uniquely identifies the floating-point number from</span>
<span class="sd">        other values of the same type, by judicious rounding. If `precision`</span>
<span class="sd">        was omitted, print out all necessary digits, otherwise digit generation</span>
<span class="sd">        is cut off after `precision` digits and the remaining value is rounded.</span>
<span class="sd">        If `False`, digits are generated as if printing an infinite-precision</span>
<span class="sd">        value and stopping after `precision` digits, rounding the remaining</span>
<span class="sd">        value.</span>
<span class="sd">    fractional : boolean, optional</span>
<span class="sd">        If `True`, the cutoff of `precision` digits refers to the total number</span>
<span class="sd">        of digits after the decimal point, including leading zeros.</span>
<span class="sd">        If `False`, `precision` refers to the total number of significant</span>
<span class="sd">        digits, before or after the decimal point, ignoring leading zeros.</span>
<span class="sd">    trim : one of &#39;k&#39;, &#39;.&#39;, &#39;0&#39;, &#39;-&#39;, optional</span>
<span class="sd">        Controls post-processing trimming of trailing digits, as follows:</span>

<span class="sd">        * &#39;k&#39; : keep trailing zeros, keep decimal point (no trimming)</span>
<span class="sd">        * &#39;.&#39; : trim all trailing zeros, leave decimal point</span>
<span class="sd">        * &#39;0&#39; : trim all but the zero before the decimal point. Insert the</span>
<span class="sd">          zero if it is missing.</span>
<span class="sd">        * &#39;-&#39; : trim trailing zeros and any trailing decimal point</span>
<span class="sd">    sign : boolean, optional</span>
<span class="sd">        Whether to show the sign for positive values.</span>
<span class="sd">    pad_left : non-negative integer, optional</span>
<span class="sd">        Pad the left side of the string with whitespace until at least that</span>
<span class="sd">        many characters are to the left of the decimal point.</span>
<span class="sd">    pad_right : non-negative integer, optional</span>
<span class="sd">        Pad the right side of the string with whitespace until at least that</span>
<span class="sd">        many characters are to the right of the decimal point.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rep : string</span>
<span class="sd">        The string representation of the floating point value</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    format_float_scientific</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_positional(np.float32(np.pi))</span>
<span class="sd">    &#39;3.1415927&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_positional(np.float16(np.pi))</span>
<span class="sd">    &#39;3.14&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_positional(np.float16(0.3))</span>
<span class="sd">    &#39;0.3&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.format_float_positional(np.float16(0.3), unique=False, precision=10)</span>
<span class="sd">    &#39;0.3000488281&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">)</span>
    <span class="n">pad_left</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">pad_left</span><span class="p">,</span> <span class="s1">&#39;pad_left&#39;</span><span class="p">)</span>
    <span class="n">pad_right</span> <span class="o">=</span> <span class="n">_none_or_positive_arg</span><span class="p">(</span><span class="n">pad_right</span><span class="p">,</span> <span class="s1">&#39;pad_right&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dragon4_positional</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="n">unique</span><span class="p">,</span>
                              <span class="n">fractional</span><span class="o">=</span><span class="n">fractional</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="n">trim</span><span class="p">,</span>
                              <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">pad_left</span><span class="o">=</span><span class="n">pad_left</span><span class="p">,</span>
                              <span class="n">pad_right</span><span class="o">=</span><span class="n">pad_right</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IntegerFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_str_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">))),</span>
                              <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_str_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="s1">&#39;%</span><span class="si">{}</span><span class="s1">d&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_str_len</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">%</span> <span class="n">x</span>


<span class="k">class</span> <span class="nc">BoolFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># add an extra space so &quot; True&quot; and &quot;False&quot; have the same length and</span>
        <span class="c1"># array elements align nicely when printed, except in 0d arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truestr</span> <span class="o">=</span> <span class="s1">&#39; True&#39;</span> <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;True&#39;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">truestr</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="s2">&quot;False&quot;</span>


<span class="k">class</span> <span class="nc">ComplexFloatingFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Formatter for subtypes of np.complexfloating &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">floatmode</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span>
                 <span class="n">sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">):</span>
        <span class="c1"># for backcompatibility, accept bools</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="n">sign</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>

        <span class="n">floatmode_real</span> <span class="o">=</span> <span class="n">floatmode_imag</span> <span class="o">=</span> <span class="n">floatmode</span>
        <span class="k">if</span> <span class="n">kwarg</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;legacy&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="n">floatmode_real</span> <span class="o">=</span> <span class="s1">&#39;maxprec_equal&#39;</span>
            <span class="n">floatmode_imag</span> <span class="o">=</span> <span class="s1">&#39;maxprec&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">real_format</span> <span class="o">=</span> <span class="n">FloatingFormat</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">floatmode_real</span><span class="p">,</span>
                                          <span class="n">suppress_small</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag_format</span> <span class="o">=</span> <span class="n">FloatingFormat</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">floatmode_imag</span><span class="p">,</span>
                                          <span class="n">suppress_small</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwarg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

        <span class="c1"># add the &#39;j&#39; before the terminal whitespace in i</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[:</span><span class="n">sp</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;j&#39;</span> <span class="o">+</span> <span class="n">i</span><span class="p">[</span><span class="n">sp</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">r</span> <span class="o">+</span> <span class="n">i</span>

<span class="c1"># for back-compatibility, we keep the classes for each complex type too</span>
<span class="k">class</span> <span class="nc">ComplexFormat</span><span class="p">(</span><span class="n">ComplexFloatingFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;ComplexFormat has been replaced by ComplexFloatingFormat&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ComplexFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LongComplexFormat</span><span class="p">(</span><span class="n">ComplexFloatingFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;LongComplexFormat has been replaced by ComplexFloatingFormat&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LongComplexFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_TimelikeFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">non_nat</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">~</span><span class="n">isnat</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_nat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Max str length of non-NaT elements</span>
            <span class="n">max_str_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_non_nat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">non_nat</span><span class="p">))),</span>
                              <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_non_nat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">non_nat</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_str_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_nat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># data contains a NaT</span>
            <span class="n">max_str_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_str_len</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="s1">&#39;%</span><span class="si">{}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_str_len</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nat</span> <span class="o">=</span> <span class="s2">&quot;&#39;NaT&#39;&quot;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">max_str_len</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_non_nat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># override in subclass</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">isnat</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_non_nat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DatetimeFormat</span><span class="p">(</span><span class="n">_TimelikeFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;same_kind&#39;</span><span class="p">,</span>
                 <span class="n">legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Get the unit from the dtype</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="n">datetime_data</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>

        <span class="k">if</span> <span class="n">timezone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timezone</span> <span class="o">=</span> <span class="s1">&#39;naive&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timezone</span> <span class="o">=</span> <span class="n">timezone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casting</span> <span class="o">=</span> <span class="n">casting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span> <span class="o">=</span> <span class="n">legacy</span>

        <span class="c1"># must be called after the above are configured</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DatetimeFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">legacy</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_non_nat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DatetimeFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_format_non_nat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">datetime_as_string</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                                    <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
                                    <span class="n">timezone</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timezone</span><span class="p">,</span>
                                    <span class="n">casting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">casting</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TimedeltaFormat</span><span class="p">(</span><span class="n">_TimelikeFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_format_non_nat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">SubArrayFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format_function</span> <span class="o">=</span> <span class="n">format_function</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format_function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>


<span class="k">class</span> <span class="nc">StructuredVoidFormat</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Formatter for structured np.void objects.</span>

<span class="sd">    This does not work on structured alias types like np.dtype((&#39;i4&#39;, &#39;i2,i2&#39;)),</span>
<span class="sd">    as alias scalars lose their field information, and the implementation</span>
<span class="sd">    relies upon np.void.__getitem__.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_functions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format_functions</span> <span class="o">=</span> <span class="n">format_functions</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a second way to initialize StructuredVoidFormat, using the raw data</span>
<span class="sd">        as input. Added to avoid changing the signature of __init__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">format_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">format_function</span> <span class="o">=</span> <span class="n">_get_format_function</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">field_name</span><span class="p">],</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
                <span class="n">format_function</span> <span class="o">=</span> <span class="n">SubArrayFormat</span><span class="p">(</span><span class="n">format_function</span><span class="p">)</span>
            <span class="n">format_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_function</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">format_functions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">str_fields</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">format_function</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">format_function</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_functions</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">str_fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">,)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">str_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">str_fields</span><span class="p">))</span>


<span class="c1"># for backwards compatibility</span>
<span class="k">class</span> <span class="nc">StructureFormat</span><span class="p">(</span><span class="n">StructuredVoidFormat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># NumPy 1.14, 2018-02-14</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;StructureFormat has been replaced by StructuredVoidFormat&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StructureFormat</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_void_scalar_repr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the repr for structured-void scalars. It is called from the</span>
<span class="sd">    scalartypes.c.src code, and is placed here because it uses the elementwise</span>
<span class="sd">    formatters defined above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">StructuredVoidFormat</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">_format_options</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>


<span class="n">_typelessdata</span> <span class="o">=</span> <span class="p">[</span><span class="n">int_</span><span class="p">,</span> <span class="n">float_</span><span class="p">,</span> <span class="n">complex_</span><span class="p">,</span> <span class="n">bool_</span><span class="p">]</span>
<span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">intc</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">_typelessdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intc</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">longlong</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">_typelessdata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">longlong</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dtype_is_implied</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine if the given dtype is implied by the representation of its values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dtype : dtype</span>
<span class="sd">        Data type</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    implied : bool</span>
<span class="sd">        True if the dtype is implied by the representation of its values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.core.arrayprint.dtype_is_implied(int)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.array([1, 2, 3], int)</span>
<span class="sd">    array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.core.arrayprint.dtype_is_implied(np.int8)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; np.array([1, 2, 3], np.int8)</span>
<span class="sd">    array([1, 2, 3], dtype=int8)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span> <span class="ow">and</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># not just void types can be structured, and names are not part of the repr</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">_typelessdata</span>


<span class="k">def</span> <span class="nf">dtype_short_repr</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a dtype to a short form which evaluates to the same dtype.</span>

<span class="sd">    The intent is roughly that the following holds</span>

<span class="sd">    &gt;&gt;&gt; from numpy import *</span>
<span class="sd">    &gt;&gt;&gt; dt = np.int64([1, 2]).dtype</span>
<span class="sd">    &gt;&gt;&gt; assert eval(dtype_short_repr(dt)) == dt</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># structured dtypes give a list or tuple repr</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">flexible</span><span class="p">):</span>
        <span class="c1"># handle these separately so they don&#39;t give garbage like str256</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">typename</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># quote typenames which can&#39;t be represented as python variable names</span>
    <span class="k">if</span> <span class="n">typename</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">typename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">and</span> <span class="n">typename</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()):</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">typename</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">typename</span>


<span class="k">def</span> <span class="nf">_array_repr_implementation</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">array2string</span><span class="o">=</span><span class="n">array2string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal version of array_repr() that allows overriding array2string.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_line_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_line_width</span> <span class="o">=</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>

    <span class="n">skipdtype</span> <span class="o">=</span> <span class="n">dtype_is_implied</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">class_name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
    <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;)&quot;</span> <span class="k">if</span> <span class="n">skipdtype</span> <span class="k">else</span> <span class="s2">&quot;,&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span> <span class="ow">and</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="n">array2string</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span>
                           <span class="s1">&#39;, &#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># show zero-length shape unless it is (0,)</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="s2">&quot;[], shape=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">),)</span>

    <span class="n">arr_str</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">lst</span> <span class="o">+</span> <span class="n">suffix</span>

    <span class="k">if</span> <span class="n">skipdtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr_str</span>

    <span class="n">dtype_str</span> <span class="o">=</span> <span class="s2">&quot;dtype=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype_short_repr</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="c1"># compute whether we should put dtype on a new line: Do so if adding the</span>
    <span class="c1"># dtype would extend the last line past max_line_width.</span>
    <span class="c1"># Note: This line gives the correct result even when rfind returns -1.</span>
    <span class="n">last_line_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr_str</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">arr_str</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">spacer</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="k">if</span> <span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">flexible</span><span class="p">):</span>
            <span class="n">spacer</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">class_name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">last_line_len</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_line_width</span><span class="p">:</span>
        <span class="n">spacer</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">class_name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">arr_str</span> <span class="o">+</span> <span class="n">spacer</span> <span class="o">+</span> <span class="n">dtype_str</span>


<span class="k">def</span> <span class="nf">_array_repr_dispatcher</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_array_repr_dispatcher</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_repr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the string representation of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    max_line_width : int, optional</span>
<span class="sd">        Inserts newlines if text is longer than `max_line_width`.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;linewidth&#39;]``.</span>
<span class="sd">    precision : int, optional</span>
<span class="sd">        Floating point precision.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;precision&#39;]``.</span>
<span class="sd">    suppress_small : bool, optional</span>
<span class="sd">        Represent numbers &quot;very close&quot; to zero as zero; default is False.</span>
<span class="sd">        Very close is defined by precision: if the precision is 8, e.g.,</span>
<span class="sd">        numbers smaller (in absolute value) than 5e-9 are represented as</span>
<span class="sd">        zero.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;suppress&#39;]``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string : str</span>
<span class="sd">      The string representation of an array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    array_str, array2string, set_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.array([1,2]))</span>
<span class="sd">    &#39;array([1, 2])&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.ma.array([0.]))</span>
<span class="sd">    &#39;MaskedArray([0.])&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(np.array([], np.int32))</span>
<span class="sd">    &#39;array([], dtype=int32)&#39;</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1e-6, 4e-7, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.array_repr(x, precision=6, suppress_small=True)</span>
<span class="sd">    &#39;array([0.000001,  0.      ,  2.      ,  3.      ])&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_array_repr_implementation</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">)</span>


<span class="n">_guarded_str</span> <span class="o">=</span> <span class="n">_recursive_guard</span><span class="p">()(</span><span class="nb">str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_str_implementation</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">array2string</span><span class="o">=</span><span class="n">array2string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal version of array_str() that allows overriding array2string.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_format_options</span><span class="p">[</span><span class="s1">&#39;legacy&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1.13&#39;</span> <span class="ow">and</span>
            <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>

    <span class="c1"># the str of 0d arrays is a special case: It should appear like a scalar,</span>
    <span class="c1"># so floats are not truncated by `precision`, and strings are not wrapped</span>
    <span class="c1"># in quotes. So we return the str of the scalar value.</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="c1"># obtain a scalar and call str on it, avoiding problems for subclasses</span>
        <span class="c1"># for which indexing with () returns a 0d instead of a scalar by using</span>
        <span class="c1"># ndarray&#39;s getindex. Also guard against recursive 0d object arrays.</span>
        <span class="k">return</span> <span class="n">_guarded_str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">()))</span>

    <span class="k">return</span> <span class="n">array2string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_str_dispatcher</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_array_str_dispatcher</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_str</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">suppress_small</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string representation of the data in an array.</span>

<span class="sd">    The data in the array is returned as a single string.  This function is</span>
<span class="sd">    similar to `array_repr`, the difference being that `array_repr` also</span>
<span class="sd">    returns information on the kind of array and its data type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Input array.</span>
<span class="sd">    max_line_width : int, optional</span>
<span class="sd">        Inserts newlines if text is longer than `max_line_width`.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;linewidth&#39;]``.</span>
<span class="sd">    precision : int, optional</span>
<span class="sd">        Floating point precision.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;precision&#39;]``.</span>
<span class="sd">    suppress_small : bool, optional</span>
<span class="sd">        Represent numbers &quot;very close&quot; to zero as zero; default is False.</span>
<span class="sd">        Very close is defined by precision: if the precision is 8, e.g.,</span>
<span class="sd">        numbers smaller (in absolute value) than 5e-9 are represented as</span>
<span class="sd">        zero.</span>
<span class="sd">        Defaults to ``numpy.get_printoptions()[&#39;suppress&#39;]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    array2string, array_repr, set_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.array_str(np.arange(3))</span>
<span class="sd">    &#39;[0 1 2]&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_array_str_implementation</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">max_line_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">suppress_small</span><span class="p">)</span>


<span class="c1"># needed if __array_function__ is disabled</span>
<span class="n">_array2string_impl</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">array2string</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">,</span> <span class="n">array2string</span><span class="p">)</span>
<span class="n">_default_array_str</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_array_str_implementation</span><span class="p">,</span>
                                       <span class="n">array2string</span><span class="o">=</span><span class="n">_array2string_impl</span><span class="p">)</span>
<span class="n">_default_array_repr</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_array_repr_implementation</span><span class="p">,</span>
                                        <span class="n">array2string</span><span class="o">=</span><span class="n">_array2string_impl</span><span class="p">)</span>


<div class="viewcode-block" id="set_string_function"><a class="viewcode-back" href="../../../api/numpy.set_string_function.html#numpy.set_string_function">[docs]</a><span class="k">def</span> <span class="nf">set_string_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set a Python function to be used when pretty printing arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : function or None</span>
<span class="sd">        Function to be used to pretty print arrays. The function should expect</span>
<span class="sd">        a single array argument and return a string of the representation of</span>
<span class="sd">        the array. If None, the function is reset to the default NumPy function</span>
<span class="sd">        to print arrays.</span>
<span class="sd">    repr : bool, optional</span>
<span class="sd">        If True (default), the function for pretty printing (``__repr__``)</span>
<span class="sd">        is set, if False the function that returns the default string</span>
<span class="sd">        representation (``__str__``) is set.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    set_printoptions, get_printoptions</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def pprint(arr):</span>
<span class="sd">    ...     return &#39;HA! - What are you going to do now?&#39;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; np.set_string_function(pprint)</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    HA! - What are you going to do now?</span>
<span class="sd">    &gt;&gt;&gt; _ = a</span>
<span class="sd">    &gt;&gt;&gt; # [0 1 2 3 4 5 6 7 8 9]</span>

<span class="sd">    We can reset the function to the default:</span>

<span class="sd">    &gt;&gt;&gt; np.set_string_function(None)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    `repr` affects either pretty printing or normal string representation.</span>
<span class="sd">    Note that ``__repr__`` is still affected by setting ``__str__``</span>
<span class="sd">    because the width of each array element in the returned string becomes</span>
<span class="sd">    equal to the length of the result of ``__str__()``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; np.set_string_function(lambda x:&#39;random&#39;, repr=False)</span>
<span class="sd">    &gt;&gt;&gt; x.__str__()</span>
<span class="sd">    &#39;random&#39;</span>
<span class="sd">    &gt;&gt;&gt; x.__repr__()</span>
<span class="sd">    &#39;array([0, 1, 2, 3])&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">repr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">_default_array_repr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">_default_array_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">multiarray</span><span class="o">.</span><span class="n">set_string_function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">repr</span><span class="p">)</span></div>

<span class="n">set_string_function</span><span class="p">(</span><span class="n">_default_array_str</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">set_string_function</span><span class="p">(</span><span class="n">_default_array_repr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">hep_spt</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../main.html">Functions and classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../numpy.html">numpy</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Miguel Ramos Pernas.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>